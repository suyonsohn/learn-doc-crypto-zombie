<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>CZombies!</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- <link rel="stylesheet" type="text/css" media="screen" href="main.css" /> -->
        <!-- <script src="main.js"></script> -->
        <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script language="javascript" type="text/javascript" src="web3.min.js"></script>
        <script language="javascript" type="text/javascript" src="cryptozombies_abi.js"></script>
    </head>
    <body>
    <!-- 
        Remember, the Ethereum network is made up of nodes, which each contain a copy of the blockchain. When you want to call a function on a smart contract, you need to query one of these nodes and tell it: 

        The address of the smart contract 
        The function you want to call
        The variables you want to pass to that function. 
        
        Ethereum nodes only speak a language called JSON-RPC, which isn't very human-readable. A query to tell the node you want to call a function on a contract looks something like this:  

        {"jsonrpc":"2.0","method":"eth_sendTransaction","params":[{"from":"0xb60e8dd61c5d32be8058bb8eb970870f07233155",   "to":"0xd46e8dd67c5d32be8058bb8eb970870f07244567","gas":"0x76c0","gasPrice":"0x9184e72a000","value":"0x9184e72a","data":"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"}],"id":1}

        Instead of needing to construct the above query, calling a function in your code will look something like this: 

        CryptoZombies.methods.createRandomZombie("Vitalik Nakamoto") .send({ from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155", gas: "3000000" })

        npm install web3 
    -->
        <script>
            // Web3.js will need 2 things to talk to your contract: its address and its ABI.

            // Contract Address
            // After you finish writing your smart contract, you will compile it and deploy it to Ethereum. After you deploy your contract, it gets a fixed address on Ethereum where it will live forever. If you recall from Lesson 2, the address of the CryptoKitties contract on Ethereum mainnet is YOUR_CONTRACT_ADDRESS. You'll need to copy this address after deploying in order to talk to your smart contract.

            // Contract ABI
            // The other thing Web3.js will need to talk to your contract is its ABI. ABI stands for Application Binary Interface. Basically it's a representation of your contracts' methods in JSON format that tells Web3.js how to format function calls in a way your contract will understand. When you compile your contract to deploy to Ethereum(which we'll cover in Lesson 7), the Solidity compiler will give you the ABI, so you'll need to copy and save this in addition to the contract address.
            var cryptoZombies;
            function startApp() {
                var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
                // Instantiate myContract
                cryptoZombies = new web3js.eth.Contract(cryptozombiesABI, cryptoZombiesAddress);
            }

            // Web3.js has two methods we will use to call functions on our contract: call and send.

            // call is used for view and pure functions. It only runs on the local node, and won't create a transaction on the blockchain. view and pure functions are read - only and don't change state on the blockchain. They also don't cost any gas, and the user won't be prompted to sign a transaction with MetaMask.
            
            // send will create a transaction and change data on the blockchain. You'll need to use send for any functions that aren't view or pure. sending a transaction will require the user to pay gas, and will pop up their Metamask to prompt them to sign a transaction. When we use Metamask as our web3 provider, this all happens automatically when we call send(), and we don't need to do anything special in our code. 

            // Recall that we made our array of zombies public:
            // Zombie[] public zombies;
            // In Solidity, when you declare a variable public, it automatically creates a public "getter" function with the same name. So if you wanted to look up the zombie with id 15, you would call it as if it were a function: zombies(15).

            // Note: All the code examples we're using in this lesson are using version 1.0 of Web3.js, which uses promises instead of callbacks. 

            function getZombieDetails(id) {
                return cryptoZombies.methods.zombies(id).call()
            }

            function zombieToOwner(id) {
                return cryptoZombies.methods.zombieToOwner(id).call()
            }

            function getZombiesByOwner(owner) {
                return cryptoZombies.methods.getZombiesByOwner(owner).call()
            }            

            // let's get it initialized and talking to the blockchain. The first thing we need is a Web3 Provider.
            // Remember, Ethereum is made up of nodes that all share a copy of the same data. Setting a Web3 Provider in Web3.js tells our code which node we should be talking to handle our reads and writes. It's kind of like setting the URL of the remote web server for your API calls in a traditional web app.

            // You could host your own Ethereum node as a provider. However, there's a third-party service that makes your life easier so you don't need to maintain your own Ethereum node in order to provide a DApp for your users — Infura. Infura is a service that maintains a set of Ethereum nodes with a caching layer for fast reads, which you can access for free through their API. Using Infura as a provider, you can reliably send and receive messages to / from the Ethereum blockchain without needing to set up and maintain your own node.

            // You can set up Web3 to use Infura as your web3 provider as follows:
            // var web3 = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));
            // However, since our DApp is going to be used by many users — and these users are going to WRITE to the blockchain and not just read from it — we'll need a way for these users to sign transactions with their private key.

            // Note: Ethereum(and blockchains in general) use a public / private key pair to digitally sign transactions. Think of it like an extremely secure password for a digital signature. That way if I change some data on the blockchain, I can prove via my public key that I was the one who signed it — but since no one knows my private key, no one can forge a transaction for me.

            // Cryptography is complicated, so unless you're a security expert and you really know what you're doing, it's probably not a good idea to try to manage users' private keys yourself in our app's front-end. But luckily you don't need to — there are already services that handle this for you. The most popular of these is Metamask. Metamask is a browser extension for Chrome and Firefox that lets users securely manage their Ethereum accounts and private keys, and use these accounts to interact with websites that are using Web3.js. 

            // Note: Metamask uses Infura's servers under the hood as a web3 provider, just like we did above — but it also gives the user the option to choose their own web3 provider. So by using Metamask's web3 provider, you're giving the user a choice, and it's one less thing you have to worry about in your app.

            // TEMPLATE code for detecting Metamask
            window.addEventListener('load', function () {
                // Checking if Web3 has been injected by the browser (Mist/MetaMask)
                if (typeof web3 !== 'undefined') {
                    // Use Mist/MetaMask's provider
                    web3js = new Web3(web3.currentProvider);
                } else {
                    // Handle the case where the user doesn't have web3. Probably 
                    // show them a message telling them to install Metamask in 
                    // order to use our app.
                }
            
                // Now you can start your app & access web3js freely:
                startApp()
            })            
        </script>
    </body>
</html>